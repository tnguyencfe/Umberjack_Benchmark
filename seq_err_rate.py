# Find the error rate of ART simulated reads by parsing the cigar strings in the SAM file produced by Art


#tu3527-read2   147     otu3527 4646    99      17=1X93=1X18=1X119=     =
import csv
import re
import subprocess
import pool.pool_traceback
import sys
import logging
import config.settings
import sam.sam_constants
from collections import defaultdict

LOGGER = logging.getLogger(__name__)
config.settings.setup_logging()


CIGAR_RE = re.compile('[0-9]+[MIDNSHPX=]')

class AlignType:
    ALN_HIT = "M"
    INSERTION = "I"
    DELETION = "D"
    SKIPPED = "N"
    SOFTCLIP = "S"
    HARDCLIP = "H"
    PAD = "P"
    SEQ_MATCH = "="
    SEQ_MISMATCH = "X"

def apply_cigar (cigar, seq, qual):
    """
    Parse SAM CIGAR and apply to the SAM nucleotide sequence.
    Remove soft-clipped sequences.  They may be valid polymorphisms but there is no alignment information for clipped
    sequences so we have no way to know how they line up with other sequences.
    Bases with low quality are not removed here - that can be done with merge_pairs()
    Left-pads and right-pads sequence so that it lines up with the reference.

    :return:  tuple [left and right padded sequence, left and right padded quality]
    :rtype : tuple [str, str]
    :param str cigar: SAM cigar field
    :param str seq: SAM sequence field
    :param str qual: SAM quality field
    """
    newseq = ''
    newqual = ''
    tokens = CIGAR_RE.findall(cigar)
    if len(tokens) == 0:
        return None, None

    left = 0

    for token in tokens:
        length = int(token[:-1])

        if token[-1] == 'S':
            left += length

        # Matching sequence: carry it over
        elif token[-1] == 'M':
            newseq += seq[left:(left+length)]
            newqual += qual[left:(left+length)]
            left += length

        # Deletion relative to reference: pad with gaps
        elif token[-1] == 'D':
            newseq += '-'*length
            newqual += '!'*length 		# Assign fake placeholder score (Q=-1)

        # Insertion relative to reference:
        elif token[-1] == 'I':
            # newseq += seq[left:(left+length)]
            # newqual += qual[left:(left+length)]
            left += length
            continue

        else:
            raise Exception("Unable to handle CIGAR token: {} - quitting".format(token))

    return newseq, newqual


def get_unclipped_seq_start (cigar, pos):
    """
    Parse SAM CIGAR.
    Returns the start position of the unclipped sequence.

    :param str cigar: SAM cigar field
    :param int pos: SAM pos field indicating start position of clipped sequence.
    """
    tokens = CIGAR_RE.findall(cigar)
    if len(tokens) == 0:
        return None

    clip_len  = 0
    first_token = tokens[0]
    length = int(first_token[:-1])
    if first_token[-1] == 'S':
        clip_len  = length

    return pos - clip_len


def get_unclipped_start_end (cigar, pos):
    """
    Parse SAM CIGAR.
    Returns the (start, end) position of the unclipped sequence.  1based positiions

    :param str cigar: SAM cigar field
    :param int pos: SAM pos field indicating start position of clipped sequence.
    """
    tokens = CIGAR_RE.findall(cigar)
    if len(tokens) == 0:
        return None

    clip_len  = 0
    first_token = tokens[0]
    length = int(first_token[:-1])
    if first_token[-1] == 'S' or first_token[-1] == "H":
        clip_len  = length

    return pos - clip_len


def write_seq_err_csv(outfile, sam_itr, procs=1):
    """
    For a set of .sam files generated by ART read simulator, finds the actual sequencing error rate.

    :param outfile:
    :return:
    """
    with open(outfile, 'w') as fh_out:
        thepool = pool.pool_traceback.LoggingPool(procs)
        writer = csv.DictWriter(fh_out, fieldnames=["Sam", "Reads", "Bp", "Aligned", "Match", "Mismatch", "Insert", "Delete",
                                                    "Qual_Aligned", "Qual_Match", "Qual_Mismatch", "Qual_Insert"])
        writer.writeheader()

        for outrow in thepool.imap_unordered(count_mismatch, sam_itr):
            writer.writerow(outrow)
        thepool.close()


def write_fraglen_csv(outfile, sam_itr, procs=1):
    """
    For a set of .sam files generated by ART read simulator, finds the actual fragment len

    :param outfile:
    :return:
    """
    with open(outfile, 'w') as fh_out:
        thepool = pool.pool_traceback.LoggingPool(procs)
        writer = csv.DictWriter(fh_out, fieldnames=["Sam", "Fraglen", "Count"])
        writer.writeheader()

        for outrows in thepool.imap_unordered(count_fraglen, sam_itr):
            writer.writerows(outrows)
        thepool.close()


def count_mismatch(samfile):
    """
    Reads a sam file generated by ART read simulator to count mismatches, indels due to sequencing error.
    :param samfile:
    :return:
    """
    with open(samfile, 'rU') as fh:
        total_mismatch = 0.0
        total_insert = 0.0
        total_deletion = 0.0
        total_hardclip = 0.0
        total_softclip = 0.0
        total_reads = 0.0
        total_bases_aligned = 0.0
        total_bases = 0.0
        total_match = 0.0
        total_aligned_qual = 0.0
        total_qual = 0.0
        total_match_qual = 0.0
        total_mismatch_qual = 0.0
        total_insert_qual = 0.0
        for line in fh:  # skip the headers
            if not line or line.startswith("@"):
                continue

            if len(line.split("\t")) < 11:
                raise ValueError(samfile + ": " + line)

            qname, flag, rname, pos, mapq, cigar, rnext, pnext, tlen, seq, qual = line.split("\t")[:11]

            total_reads += 1

            tokens = CIGAR_RE.findall(cigar)
            qual_idx = 0
            for token in tokens:
                # last letter in token indicates the type of alignment.  The number prior indicate the length of the alignment
                token_type = token[-1]
                token_len = int(token[:-1])
                token_qual = qual[qual_idx:qual_idx+token_len]

                total_token_qual = sum([ord(qchar) - sam.sam_constants.PHRED_SANGER_OFFSET for qchar in token_qual])

                if token_type != AlignType.DELETION and token_type != AlignType.PAD:
                    total_bases += token_len
                    total_qual += total_token_qual

                if token_type  != AlignType.HARDCLIP and token_type != AlignType.SOFTCLIP and token_type != AlignType.DELETION and token_type != AlignType.PAD:
                    total_bases_aligned += token_len
                    total_aligned_qual += total_token_qual

                if token_type == AlignType.SEQ_MISMATCH:
                    total_mismatch += token_len
                    total_mismatch_qual += total_token_qual
                elif token_type == AlignType.SEQ_MATCH or token_type == AlignType.ALN_HIT:
                    total_match += token_len
                    total_match_qual += total_token_qual
                elif token_type == AlignType.DELETION:
                    total_deletion += token_len
                elif token_type == AlignType.INSERTION:
                    total_insert += token_len
                    total_insert_qual += total_token_qual
                elif token_type == AlignType.HARDCLIP:
                    total_hardclip += token_len
                elif token_type == AlignType.SOFTCLIP:
                    total_softclip += token_len

                qual_idx += token_len

        outrow = dict(Sam=samfile,
                      Reads=total_reads,
                      Bp=total_bases,
                      Aligned=None if not total_bases else total_bases_aligned/total_bases,
                      Match=None if not total_bases_aligned else total_match/total_bases_aligned,
                      Mismatch=None if not total_bases_aligned else total_mismatch/total_bases_aligned,
                      Insert=None if not total_bases_aligned else total_insert/total_bases_aligned,
                      Delete=None if not total_bases_aligned else total_deletion/total_bases_aligned,
                      Qual_Aligned=None if not total_bases_aligned else total_aligned_qual/total_bases_aligned,
                      Qual_Match=None if not total_match else total_match_qual/total_match,
                      Qual_Mismatch=None if not total_mismatch else total_mismatch_qual/total_mismatch,
                      Qual_Insert=None if not total_insert else total_insert_qual/total_insert)
        return outrow


def count_fraglen(samfile):
    """
    Reads a sam file generated by ART read simulator to count mismatches, indels due to sequencing error.
    :param samfile:
    :return:
    """
    fraglen_to_count = defaultdict(int)
    with open(samfile, 'rU') as fh:
        for line in fh:  # skip the headers
            if not line or line.startswith("@"):
                continue

            if len(line.split("\t")) < 11:
                raise ValueError(samfile + ": " + line)

            qname, flag, rname, pos, mapq, cigar, rnext, pnext, tlen, seq, qual = line.split("\t")[:11]
            fraglen_to_count[abs(int(tlen))] += 1

    outrows = []
    for fraglen, count in fraglen_to_count.iteritems():
        outrow = dict(Sam=samfile, Fraglen=fraglen, Count=count)
        outrows.append(outrow)
    return outrows



def get_next_record(sam_handle):
    for line in sam_handle:
        if not line.startswith("@"):
            qname, flag_str, rname, pos_str, mapq_str, cigar  = line.split("\t")[:6]
            flag = int(flag_str)
            pos = int(pos_str)
            mapq = int(mapq_str)
            return qname, flag, rname, pos, mapq, cigar

    return None

def is_record_same_ahead(query1, flag1, query2, flag2):
    """
    Returns if record1 is at same or ahead of record 2in terms of query sorted.
    :param query1:
    :param flag1:
    :param query2:
    :param flag2:
    :return:
    """
    IS_FIRST =                 0x040
    IS_SECOND =                0x080
    IS_SECONDARY_ALIGNMENT =   0x100
    IS_CHIMERIC_ALIGNMENT =    0x800
    if ((query1 > query2) or
            (query1 == query2 and flag1 & IS_FIRST and flag2 & IS_FIRST) or
            (query1 == query2 and flag1 & IS_SECOND and flag2 & IS_SECOND) or
            (query1 == query2 and flag1 & IS_SECOND and flag2 & IS_FIRST)):
        return True
    return False

def is_record_ahead(query1, flag1, query2, flag2):
    """
    Returns if record1 is at same or ahead of record 2in terms of query sorted.
    :param query1:
    :param flag1:
    :param query2:
    :param flag2:
    :return:
    """
    IS_FIRST =                 0x040
    IS_SECOND =                0x080
    IS_SECONDARY_ALIGNMENT =   0x100
    IS_CHIMERIC_ALIGNMENT =    0x800
    if ((query1 > query2) or
            (query1 == query2 and flag1 & IS_FIRST and flag2 & IS_SECOND)):
        return True
    return False

def is_record_same(query1, flag1, query2, flag2):
    """
    Returns if record1 is at same or ahead of record 2in terms of query sorted.
    :param query1:
    :param flag1:
    :param query2:
    :param flag2:
    :return:
    """
    IS_FIRST =                 0x040
    IS_SECOND =                0x080
    IS_SECONDARY_ALIGNMENT =   0x100
    IS_CHIMERIC_ALIGNMENT =    0x800

    if ((query1 == query2 and flag1 & IS_FIRST and flag2 & IS_FIRST) or
            (query1 == query2 and flag1 & IS_SECOND and flag2 & IS_SECOND)):
        return True
    return False



def cmp_art_aln_sam(art_samfile, aln_samfile):
    """
    Compares the true read placement as generated by the ART read simulator vs aligned read placement as determined by an aligner.
    ASSUMES the art sam file and the aln_samefile have been queryname sorted.
    ASSUMES that the art sam file will contain every read.
    ASSUMES that the aln sam file can have >=0 alignments for every read.
    :param art_samfile:
    :param aln_samfile:
    :return:
    """
    total_wrong = 0
    total_art_mate_alns = 0.0
    print "\nComparing Alignments for " + art_samfile + " and " + aln_samfile
    print "========================="
    with open(art_samfile, 'rU') as fh_art, open(aln_samfile, 'rU') as fh_aln:

        is_more_art = True
        last_qname_art = None
        last_qname_aln = None
        last_flag_art = None
        last_flag_aln = None
        last_pos_art = None

        qname_art = None
        flag_art = 0
        rname_art = None
        mapq_art = None
        pos_art = None
        cigar_art = None
        art_rec = qname_art, flag_art, rname_art, pos_art, mapq_art, cigar_art

        qname_aln = None
        flag_aln = 0
        rname_aln = None
        mapq_aln = None
        pos_aln = None
        cigar_aln = None
        aln_rec = qname_aln, flag_aln, rname_aln, pos_aln, mapq_aln, cigar_aln

        while is_more_art:
            if not last_qname_art or is_record_same_ahead(last_qname_aln, last_flag_aln, last_qname_art, last_flag_art):  # advance art if the aln is further ahead or same
                art_rec = get_next_record(fh_art)
                if art_rec:
                    total_art_mate_alns += 1
                    qname_art, flag_art, rname_art, pos_art, mapq_art, cigar_art  = art_rec
                else:
                    is_more_art = False



            if not last_qname_aln or is_record_same_ahead(last_qname_art, last_flag_art, last_qname_aln, last_flag_aln):  # advance aln if art is further ahead or same
                aln_rec = get_next_record(fh_aln)
                if aln_rec:
                    qname_aln, flag_aln, rname_aln, pos_aln, mapq_aln, cigar_aln  = aln_rec

            if is_record_ahead(qname_aln, flag_aln, qname_art, flag_art):
                print("Missing alignment for " + qname_art + " flag=" + str(flag_art) + " current alnqname=" + qname_aln)
                total_wrong += 1
            elif is_record_same(qname_aln, flag_aln, qname_art, flag_art):
                if pos_aln != pos_art:
                    unclipped_pos_aln = get_unclipped_seq_start(cigar=cigar_aln, pos=pos_aln)
                    if unclipped_pos_aln != pos_art:
                        print "Wrong position for " + qname_art + " artpos=" + str(pos_art) + " alnpos(unclipped)=" + str(unclipped_pos_aln)
                        total_wrong += 1
            elif is_record_same(qname_aln, flag_aln, last_qname_art, last_flag_art):
                if pos_aln != last_pos_art:
                    unclipped_pos_aln = get_unclipped_seq_start(cigar=cigar_aln, pos=pos_aln)
                    if unclipped_pos_aln != last_pos_art:
                        print "Wrong position for " + last_qname_art + " artpos=" + str(last_pos_art) + " alnpos(unclipped)=" + str(unclipped_pos_aln)
                        total_wrong += 1

            last_qname_art = qname_art
            last_qname_aln = qname_aln
            last_flag_art = flag_art
            last_flag_aln = flag_aln
            last_pos_art = pos_art

    print "\nComparison results for " + art_samfile + " and " + aln_samfile
    print ("Total Mates wrong = " + str(total_wrong) + "\n Fraction Mates wrong = " + str(total_wrong/total_art_mate_alns))




if __name__ == "__main__":
    outfile = sys.argv[1]
    procs = int(sys.argv[2])
    sams = sys.argv[3].split(",")
    write_seq_err_csv(outfile=outfile, sam_itr=sams, procs=procs)
    write_fraglen_csv(outfile=outfile.replace(".csv", ".fraglen.csv"), sam_itr=sams, procs=procs)




